# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

row_arma <- function(x, cores) {
    .Call('spatialtalk_row_arma', PACKAGE = 'spatialtalk', x, cores)
}

col_arma <- function(x, cores) {
    .Call('spatialtalk_col_arma', PACKAGE = 'spatialtalk', x, cores)
}

self_crossprod_arma <- function(x) {
    .Call('spatialtalk_self_crossprod_arma', PACKAGE = 'spatialtalk', x)
}

crossprod_arma <- function(x, y) {
    .Call('spatialtalk_crossprod_arma', PACKAGE = 'spatialtalk', x, y)
}

self_tcrossprod_arma <- function(x) {
    .Call('spatialtalk_self_tcrossprod_arma', PACKAGE = 'spatialtalk', x)
}

tcrossprod_arma <- function(x, y) {
    .Call('spatialtalk_tcrossprod_arma', PACKAGE = 'spatialtalk', x, y)
}

nll_eigen <- function(x, d, z, n) {
    .Call('spatialtalk_nll_eigen', PACKAGE = 'spatialtalk', x, d, z, n)
}

#' @title First Tapering Implementation
#' @description The function implements the first tapering method described
#' in the Covariance Tapering paper.
#' @param x A \code{double}
#' @param n A \code{double} that indicates the matrix row/col.
#' @param good_dists A \code{VectorXd} that contains the distances which meet tapering requirements
#' @param taps A \code{VectorXd} results of applying the taper function
#' @param ia A \code{VectorXd} containing the ordered row indices
#' @param ja A \code{VectorXd} containing the ordered column indices
#' @param z A \code{VectorXd} element position in matrix 
#' @param rescol An \code{int} that contains how many non-zero elements should be in a column. 
#' @return A \code{double}
#' @details Currently the EIGEN sparse matrix cholesky decomposition differs from that of SPAM. 
#' As a result, the forward solve step finds a different vector. This in turn returns a higher distval.
#' @examples
#' data(anom1962)
#' d = rdist_earth1(loc)
#' setup.eigen = make_tapersetup_eigen(d,taprange = 50)
#' val = nll_1taper(20, setup.eigen$n,
#'                  setup.eigen$good.dists,
#'                  setup.eigen$taps,
#'                  setup.eigen$ia,
#'                  setup.eigen$ja,
#'                  z,
#'                  setup.eigen$rescol)
nll_1taper <- function(x, n, good_dists, taps, ia, ja, z, rescol) {
    .Call('spatialtalk_nll_1taper', PACKAGE = 'spatialtalk', x, n, good_dists, taps, ia, ja, z, rescol)
}

#' @title Second Tapering Implementation
#' @description The function implements the second tapering method described
#' in the Covariance Tapering paper.
#' @param x A \code{double}
#' @param n A \code{double} that indicates the matrix row/col.
#' @param good_dists A \code{VectorXd} that contains the distances which meet tapering requirements
#' @param taps A \code{VectorXd} results of applying the taper function
#' @param ia A \code{VectorXd} containing the ordered row indices
#' @param ja A \code{VectorXd} containing the ordered column indices
#' @param z A \code{VectorXd} element position in matrix 
#' @param rescol An \code{int} that contains how many non-zero elements should be in a column. 
#' @return A \code{double}
#' @details Currently the EIGEN sparse matrix cholesky decomposition differs from that of SPAM. 
#' As a result, the backsolve and forwardsolve step finds a different vector. 
#' This in turn returns a higher distval.
#' @examples
#' data(anom1962)
#' d = rdist_earth1(loc)
#' setup.eigen = make_tapersetup_eigen(d,taprange = 50)
#' val = nll_2taper(20, setup.eigen$n,
#'                  setup.eigen$good.dists,
#'                  setup.eigen$taps,
#'                  setup.eigen$ia,
#'                  setup.eigen$ja,
#'                  z,
#'                  setup.eigen$rescol)
nll_2taper <- function(x, n, good_dists, taps, ia, ja, z, rescol) {
    .Call('spatialtalk_nll_2taper', PACKAGE = 'spatialtalk', x, n, good_dists, taps, ia, ja, z, rescol)
}

#' @describeIn nll_1taper
#' @param cores An \code{int} that indicates the number of cores to divide the task over.
nll_1taper_parallel <- function(x, n, good_dists, taps, ia, ja, z, rescol, cores) {
    .Call('spatialtalk_nll_1taper_parallel', PACKAGE = 'spatialtalk', x, n, good_dists, taps, ia, ja, z, rescol, cores)
}

#' @describeIn nll_2taper
#' @param cores An \code{int} that indicates the number of cores to divide the task over.
nll_2taper_parallel <- function(x, n, good_dists, taps, ia, ja, z, rescol, cores) {
    .Call('spatialtalk_nll_2taper_parallel', PACKAGE = 'spatialtalk', x, n, good_dists, taps, ia, ja, z, rescol, cores)
}

backsolve_arma <- function(r, x, k = 0L, transpose = FALSE) {
    .Call('spatialtalk_backsolve_arma', PACKAGE = 'spatialtalk', r, x, k, transpose)
}

forwardsolve_arma <- function(l, x, k = 0L, transpose = FALSE) {
    .Call('spatialtalk_forwardsolve_arma', PACKAGE = 'spatialtalk', l, x, k, transpose)
}

ifelse_arma <- function(a) {
    .Call('spatialtalk_ifelse_arma', PACKAGE = 'spatialtalk', a)
}

rdist_earth1 <- function(x1, miles = TRUE, R = 0) {
    .Call('spatialtalk_rdist_earth1', PACKAGE = 'spatialtalk', x1, miles, R)
}

nll_arma_corr <- function(x, d) {
    .Call('spatialtalk_nll_arma_corr', PACKAGE = 'spatialtalk', x, d)
}

nll_arma_chol <- function(corr_matrix) {
    .Call('spatialtalk_nll_arma_chol', PACKAGE = 'spatialtalk', corr_matrix)
}

nll_arma_det <- function(Q) {
    .Call('spatialtalk_nll_arma_det', PACKAGE = 'spatialtalk', Q)
}

nll_arma_bs <- function(Q, z) {
    .Call('spatialtalk_nll_arma_bs', PACKAGE = 'spatialtalk', Q, z)
}

nll_arma_dist <- function(bs) {
    .Call('spatialtalk_nll_arma_dist', PACKAGE = 'spatialtalk', bs)
}

nll_arma_all <- function(n, distval, logdet) {
    .Call('spatialtalk_nll_arma_all', PACKAGE = 'spatialtalk', n, distval, logdet)
}

#' @title Taper Function
#' @description Taper function we're using
#' @param d A \code{vec} containing the small distance values
#' @param taprange A \code{double} indicating the taper range
#' @return A \code{vec} that has had tapering applied to d.
#' @examples
#' data(anom1962)
#' d = rdist_earth1(head(loc))
#' wendland2_1(d, 20)
wendland2_1 <- function(d, taprange) {
    .Call('spatialtalk_wendland2_1', PACKAGE = 'spatialtalk', d, taprange)
}

#' @title Create a taper setup for a SPAM matrix
#' @description Get the storage information we'll need to create a sparse matrix
#' @param d A \code{matrix} that is a symmetric distance matrix.
#' @param taprange A \code{double} that is used to specify the gamma.
#' @return A \code{list}
#' \itemize{
#' \item \code{n} - row/col of matrix
#' \item \code{good.dists} - distances that meet tapering requirements
#' \item \code{taps} - results of applying the taper function
#' \item \code{ja} - ordered column indices
#' \item \code{ia} -  pointer to the beginning of each row in the arrays entries and colindices
#' \item \code{index} - element position in matrix 
#' }
#' @details This function is meant to be used to create SPAM matrices.
#' Do not use output for Eigen matrices.
#' @examples
#' data(anom1962)
#' d = rdist_earth1(head(loc))
#' make_tapersetup_R(d, 20)
make_tapersetup_R <- function(d, taprange) {
    .Call('spatialtalk_make_tapersetup_R', PACKAGE = 'spatialtalk', d, taprange)
}

#' @title Create a taper setup for an Eigen sparse matrix
#' @description Generate the storage information we'll need to create a sparse eigen matrix
#' @param d A \code{matrix} that is a symmetric distance matrix.
#' @param taprange A \code{double} that is used to specify the gamma.
#' @return A \code{list}
#' \itemize{
#' \item \code{n} - row/col of matrix
#' \item \code{good.dists} - distances that meet tapering requirements
#' \item \code{taps} - results of applying the taper function
#' \item \code{ja} - column index
#' \item \code{ia} - row index
#' }
#' @details This function is meant to be used to create SPAM matrices.
#' The function formats data so that it can be used with a compressed sparse column format.
#' Do not use output for Eigen matrices.
#' @examples
#' data(anom1962)
#' d = rdist_earth1(head(loc))
#' make_tapersetup_eigen(d, 20)
make_tapersetup_eigen <- function(d, taprange) {
    .Call('spatialtalk_make_tapersetup_eigen', PACKAGE = 'spatialtalk', d, taprange)
}

#' @title Create a taper setup for an Eigen sparse matrix
#' @description Generate the storage information we'll need to create a sparse eigen matrix
#' @param x A \code{double} that represents rho, which is the scaling parameter of the exponential covariance function
#' @param d A \code{matrix} that is a symmetric distance matrix.
#' @param z A \code{vec} that contains the finite number of observations
#' @param n A \code{double} that indicates the number of rows/cols of the matrix.
#' @return A \code{double}
#' @examples
#' data(anom1962)
#' d = rdist_earth1(head(loc))
#' nll_arma(20, d, z, n)
nll_arma <- function(x, d, z, n) {
    .Call('spatialtalk_nll_arma', PACKAGE = 'spatialtalk', x, d, z, n)
}

#' @describeIn nll_arma
#' @param cores A \code{integer} representing how many cores should be loaded
nll_parallel <- function(x, d, z, n, cores = 1L) {
    .Call('spatialtalk_nll_parallel', PACKAGE = 'spatialtalk', x, d, z, n, cores)
}

